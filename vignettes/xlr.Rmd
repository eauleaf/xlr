---
title: "xlr"
author: "Eauleaf"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{xlr}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r install-xlr, eval = T, include = FALSE}
library(xlr)
```


<br>


## ***R + Spreadsheets***




<br>


*Package is currently somewhere between dev and beta.*

##### Install: 
```{r download-xlr, eval = F}
remotes::install_github('eauleaf/xlr')
library(xlr)
```


<br>

## Overview:


**xlr** makes it easier to move information between **spreadsheets** and **R**.

<br>

Spreadsheets are an excellent tool for presenting 2-dimensional data in a
reader-friendly format and are the workhorse of the business community, but
spreadsheets don't have the flexibility or power of R, so its common for 
data professionals to work in both spreadsheets and R. However, working in both can be 
frustrating. It's time expensive to read data back forth between the
two, and 95% of the time, I just want to send decent-looking tables out to a spreadsheet.
**xlr** is an effort to reduce the friction that comes from having to work in both 
spreadsheets and R.



## Functions:

-   **`xl()`** -- quickly output a list of datasets as spreadsheets in a workbook
-   **`enlist()`** -- make named lists without additional nesting
-   **`copy_for_xl()`** -- copy an R dataset to clipboard memory, formatted for pasting
    to a spreadsheet
-   **`paste_from_xl()`** -- copy spreadsheet data to clipboard memory, formatted for
    pasting to R
-   **`enscript()`** -- produce the code to re-create an R object
-   **`repeated()`** -- flag all repeats in a vector
-   **`sys_open()`** -- request the OS open files or folders from paths
-   **`list_iron()`** -- flatten lists of embedded lists to a named, single-file list
-   **`entibble()`** -- create tibbles with default behavior useful for spreadsheets


<br>


## How to use 'xlr':


<br>


# `xl()`

`xl()` is the primary function of the package 'xlr', and many
of the other functions in the package were developed to help it.
The function is somewhat similar to `View()` from the `utils` package in
that `xl()` is for quickly viewing datasets. 

It's easiest to see what `xl()` does by passing it some example data;
try sending it some pre-loaded datasets, like:

```{r xlr-example1, eval = F}
xl(mtcars, iris, letters, Titanic, AirPassengers)
```

If you type that code to the R console, you should get a workbook that
pops open automatically with those datasets presented in standardized,
formatted sheets. Once you're done with the workbook, all you have to do
is close it; your spreadsheets are temporary. Close them, and they're
gone.

The video below is of `xl()` creating a temporary workbook where each
data object becomes a labeled spreadsheet in the workbook.

![xl(iris, mtcars, 1:100, dplyr::starwars)](www/Screencast-xl.webm)


### `xl()` use details:

To use `xl()`, pass a dataframe or lists of dataframes. It does not
matter if you pass nested lists of lists where your data objects are
buried at various depths, `xl()` will flatten and auto-name the
workbook and the spreadsheet tabs. Nested lists can be useful for the
naming of groups on spreadsheet tabs.

Try running the below examples in your console.

```         
xl(some_datasets = enlist(flowers = iris, mtcars, datasets::USArrests)) 

iris |> split(f = iris$Species) |> xl()
```

`xl()` writes the workbook in a temp directory and, to keep workbooks
from building up, uses `later::later()` to remove the savefile 5 minutes
after your write time. Temp directories also delete themselves when you
close R. If, however, you want to save a workbook, specify a path or
just a save name in the `xl()` input parameter `.path`. Specifying a
savename signals to `xl()` not to mark the file for cleanup. (Note that
parameter `.path` uses `here::here()` internally.)

`xl()` creates tibbles of all datasets you pass in, and if specified by
the user parameter `.return`, will optionally return (invisibly) the
data objects in a list, or the `openxlsx` workbook object in case you want to change 
things in the workbook, or the workbook savepath as a string.


<br>


# `enlist()`

`enlist()` is for easy list naming. This function produces
named lists, without list-nesting when passed a single bare list. That
is, unlike `list()`, `enlist()` removes its own embedded list layer if
the user passes in a list.

For instance, compare the structure and naming created by enlist:

```{r enlist-example1, eval = T}
enlist(enlist(enlist('hello'))) |> str()
```

To the structure and naming created by list:

```{r enlist-example2, eval = T}
list(list(list('hello'))) |> str()
```

The `enlist` example is one list deep, whereas the `list` example is
three lists deep. However, if you send two list objects into enlist, as
shown in the example below, enlist has no choice but to wrap them in a
new list.

```{r enlist-example3, eval = T}
enlist(list(letters), list(letters)) |> str()
```

### A few additional notes about `enlist()`: 

-- Naming is permissive, you can have duplicate names in a list, so be careful 
about indexing by name. R returns only the first observation it finds in the list.

-- Enlist has input parameter `.label`, that takes a naming function. Internally, `.label` is passed to `nm` in `rlang::set_names()` and so takes the same inputs. 

-- `enlist()` supports non-standard evaluation.


### Some clipboard notes:

The next 3 `xlr` functions, use the clipboard memory. 
To use the clipboard, install the `clipr` package and then check that the 
package works by running `clipr::dr_clipr().` Also, if using Linux, like me,
make sure to install a clipboard tool from a terminal: `sudo apt-get install xclip`.


<br>


# `copy_for_xl()`

`copy_for_xl()` copies data to your clipboard memory that's formatted
for pasting to cells in a spreadsheet. You can pass a data object to it,
like:

```{r copy_for_xl-example, eval = F}
copy_for_xl(mtcars)
```

### `copy_for_xl()` key-chord

However, a copying method that is way, way better is to use the quick
keys `ctrl + alt + shift + c`. To use these quick keys, run the
function, `set_xlr_key_chords()`. (To set up quick keys, you only ever have to
run this function once in RStudio, but you have to close down RStudio and the 
re-open for the new quick keys to be active.) Then:

1) Type `mtcars` in an RStudio text editor window (not in the console window)

2) Use your cursor to highlight the word `mtcars`, and 

3) Press `ctrl + alt + shift + c` all together. (It's just like copying with 
`ctrl + c`, but instead use all 3 control keys, plus the `c`.)


You should see `✔ Table copied to clipboard:` written in the console.
Open a spreadsheet and paste the copied `mtcars` data to it.

The below video example uses `copy_for_xl()`, via the console, to copy some 
starwars data.
![copy_for_xl(dplyr::starwars)](www/Screencast-copy_for_xl.webm)


<br>


# `paste_from_xl()`

`paste_from_xl()` pastes data from your clipboard memory to an R tibble
object. You can pass spreadsheet data to R by copying data from your
spreadsheet, and then by typing the following into the console:

```{r paste_from_xl-example, eval = F}
my_data <- paste_from_xl()
```

The function guesses whether you have field names present, but if the
function guessed wrong, you can specify with the parameter
`has_fieldnames`, like below:

```{r paste_from_xl-example2, eval = F}
my_data <- paste_from_xl(has_fieldnames = TRUE)
```

### `paste_from_xl()` key-chord

However, a pasting method that is way, way better is to use the quick
keys `ctrl + alt + shift + v`. To use this key-chord, run the function, 
`set_xlr_key_chords()` if you haven't already done so. Then: 

1) Copy some data from a spreadsheet. 

2) Click over to the RStudio console or to an RStudio editor. (The console and 
editor have different paste_from_xl() functionality.) 

3) Press `ctrl + alt + shift + v` all together to paste. (Just
like pasting with `ctrl + v`, but using all 3 control keys, plus the `v`.)


You should see a tibble of your spreadsheet data assigned to a variable
and the dataset echoed to the console. However, if you pressed 
`ctrl + alt + shift + v`, and you were over an editor
window instead of the console, you also get formatted code written into
the editor window that will recreate the data object from script. The script is
a formatted version of R's deparsed internal data representation.


### `paste_from_xl()` copy workbook paths
In addition to spreadsheet data, you can copy file paths with `paste_from_xl()`. 
Open a file navigation window in your operating system, highlight a 
few files or folders, and press `ctrl + c`; then go back to RStudio, click on an editor 
window, and press the key-chord `ctrl + alt + shift + v`, you get an 
enscripted vector of file paths pasted into your text editor.

The video below is an example of copying file paths and then using key-chord
`ctrl + alt + shift + v` in RStudio.

![ctrl + alt + shift + v](www/Screencast-paste_from_xl-paths.webm)


<br>


# `enscript()`

I often process data manually down to particular information that's too
small to deal with saving and retrieving from a serialized
file or database. Instead, I just want to save the information as text within
the script, but I hate manually recreating the object.

If you have an object in a variable, and want that variable's data to be deparsed
into a formatted script, pass that variable into `enscript()`, as in:

```{r enscript-example1, eval = F}
enscript(mtcars)
```

`enscript()` copies formatted code to your clipboard that will reproduce
that variable's internal R object.

You can also pass in an expression by piping 'enscript()' onto the end
of anything, like:

```{r enscript-example2, eval = F}
iris |> split(f = iris$Species) |> purrr::map(head, 3) |> enscript()
```

### `enscript()` key-chord

It's also convenient to use the quick keys for `enscript()`,
which are `ctrl + alt + shift + n`. (I remember the key-chord as all three
control keys, plus the `n`, which is short for enscript.)

To use the `enscript()` quick keys, Run the function, `set_xlr_key_chords()` if you haven't already done so. Then:

1) Then type a variable name like `mtcars` in your RStudio editor window (not in the console). 

2) Use your cursor to highlight the word `mtcars`. 

3) Press `ctrl + alt + shift + n` all together.

You should see the success message, `✔ Script copied to clipboard:`,
written to the console with the deparsed object echoed below it. You can
now paste a formatted script into an editor window or the console with
`ctrl + v`.

You can also highlight an entire expression in an editor window, and
then key-chord `ctrl + alt + shift + n`. Expressions evaluate and 
produce a deparsed script that is copied to the clipboard.

Note that the `enscript()` quick keys only work for a highlighted
variable or highlighted expression in the RStudio editor window; the
quick keys do not interpret anything highlighted in the console.


<br>


# `repeated()`

I use `repeated()` all the time and wish it were in `dplyr`. When I
filter a dataframe, I often need to quickly see all the observations
that show up more than once, like:

```{r repeated-example, eval = T}
mtcars |> dplyr::filter(repeated(disp))
```

`repeated()` is just `x %in% x[duplicated(x)]` with some assertion
checks, but way easier to remember than `x %in% x[duplicated(x)]`. Use it
in `and` and `or` statements like this: 

```{r repeated-example2, eval = F}
# AND statements
mtcars |> dplyr::filter(repeated(hp), repeated(disp))
# OR statements
mtcars |> dplyr::filter(repeated(hp) | repeated(disp))
```


<br>


# `sys_open()`

`sys_open()` opens .xlsx files, but also any file or folder. This function passes a
path string (or many, if you like) to your operating system's command line
interface, asking it to open up the location using the default application.

If you aren't able to open a file with `sys_open()`, using your operating system's 
navigation window, right-click on the file to make sure your operating system
has a default application assigned that file type, and that double-clicking the 
file opens it in that default application.

The video below is an example of opening up some PDF files by piping them from 
`paste_from_xl()` to `sys_open()`. 

![sys_open(paste_from_xl())](www/Screencast-sys_open.webm)


<br>


# `list_iron()`

`list_iron()` takes any nested list of lists and irons it out to get a
single-file list of objects.

Because an xlsx workbook can only make spreadsheets out of a simple,
flat list of data objects, `list_iron()` recursively smooshes any
additional list structure out of the input. `list_iron()` also has a few
convenience features for naming the list objects and applying a function
to each. Consider the ridiculous list structure below and list_iron's
simplification of it:

```{r list_iron-example, eval = T}
rediculous <- list(list(list(list(flower_data = iris)), car_data = mtcars))

# Original list depth
rediculous |> str()

# Ironed list depth
rediculous |> list_iron() |> str()
```

Notice the auto-naming of the list items above, i.e.
*'rediculous\|flower_data'*; you can control that naming. You can also apply a
function while flattening all of the leaves in the lists with the
parameter `.f`, as shown below:

```{r list_iron-example2, eval = T}
list_iron(rediculous, .f = ~tail(.,2))
```


<br>


# `entibble()`

`entibble()` makes tibbles, but has defaults useful for spreadsheets.
`entibble()` automatically includes rownames, if they exist, in the
tibble. It does not repeat input elements to obtain common lengths in
order to produce a dataframe, and it treats a list of data inputs equivalent to 
comma-separated data inputs.

For example, compare the tibbled and entibbled data below.

```{r entibble-example, eval = T}
alpha <- rlang::set_names(letters)

# rownames are forced in so they show up in spreadsheets
entibble(alpha) |> head(2)
tibble::tibble(alpha) |> head(2)

# lists passed to entibble are dumped and their objects joined like any other 
# input if the listed objects have compatible row dimensions
entibble(list(alpha), LETTERS) |> tail(2)
tibble::tibble(list(alpha), LETTERS) |> tail(2)
```

